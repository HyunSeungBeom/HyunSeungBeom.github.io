---
title: "[Deep Dive] Next.js 캐싱 전략 (Request Memoization, Data Cache, Full Route Cache)"
date: 2026-02-07 08:08:31 +0900
categories: [개발뉴스]
tags: [CS, 심화]
---

## 표면적 이해
Next.js 캐싱 전략은 Request Memoization, Data Cache, Full Route Cache를 포함하는 기술로 웹 페이지 로딩 속도와 사용자 경험을 개선한다.

## Deep Dive

### 왜 필요한가?
- Next.js 캐싱 전략은 웹 페이지의 로딩 속도를 개선하고, 사용자 경험을 향상시키기 위해 필요하다. 기존의 웹 페이지는 매번 요청마다 데이터베이스나 API를 호출하여 데이터를 가져와서 페이지를 렌더링한다. 그러나 방식은 서버의 부담을 가중시키고, 사용자에게 느린 로딩 속도를 제공한다.
- 이전 방식의 한계는 데이터의 불변성과 캐싱의 부재이다. 데이터가 자주 변경되지 않더라도, 매번 요청마다 데이터를 새로 불러오므로 불필요한 네트워크 요청과 서버의 부담을 초래한다.

### 내부 동작 원리
- Next.js 캐싱 전략은 세 가지 방법을 제공한다. 첫 번째는 Request Memoization으로, 동일한 요청에 대한 응답을 캐싱하여 이후의 요청에 빠르게 응답할 수 있다. 두 번째는 Data Cache로, 데이터를 캐싱하여 데이터베이스나 API를 호출하지 않도록 한다. 세 번째는 Full Route Cache로, 페이지를 캐싱하여 라우팅 전환 시 빠르게 렌더링할 수 있다.
```
         +---------------+
         |  Request    |
         +---------------+
                  |
                  |
                  v
         +---------------+
         | Request Memoization |
         |  ( 캐싱된 응답 )    |
         +---------------+
                  |
                  |
                  v
         +---------------+
         | Data Cache     |
         |  ( 캐싱된 데이터 ) |
         +---------------+
                  |
                  |
                  v
         +---------------+
         | Full Route Cache |
         |  ( 캐싱된 페이지 ) |
         +---------------+
```

### 코드로 이해하기
```typescript
// getStaticProps를 사용하여 prefetching과 캐싱을 적용
import { GetStaticProps } from 'next';

const HomePage = () => {
  return <div>홈 페이지</div>;
};

export const getStaticProps: GetStaticProps = async () => {
  return {
    props: {},
    revalidate: 60, // 1분마다
  };
};

export default HomePage;
```

```typescript
// 잘못된 사용 예
// getServerSideProps를 사용하여 매번 데이터를 새로 불러옴
import { GetServerSideProps } from 'next';

const HomePage = () => {
  return <div>홈 페이지</div>;
};

export const getServerSideProps: GetServerSideProps = async () => {
  const data = await fetch('https://api.example.com/data');
  return {
    props: {
      data: await data.json(),
    },
  };
};

export default HomePage;
```

```typescript
// 올바른 사용 예
// getStaticProps와 함께 revalidate를 사용하여 캐싱과 갱신을 적용
import { GetStaticProps } from 'next';

const HomePage = () => {
  return <div>홈 페이지</div>;
};

export const getStaticProps: GetStaticProps = async () => {
  const data = await fetch('https://api.example.com/data');
  return {
    props: {
      data: await data.json(),
    },
    revalidate: 60, // 1분마다
  };
};

export default HomePage;
```

### 비교 분석

| 구분 | Request Memoization | Data Cache | Full Route Cache |
|------|---------------------|------------|------------------|
| 캐싱대상 | 응답 | 데이터 | 페이지 |
| 캐싱 방식 | 응답 캐싱 | 데이터 캐싱 | 페이지 캐싱 |
| 갱신 방식 | 요청 시 갱신 | 데이터 변경 시 갱신 | 라우팅 전환 시 갱신 |

### 실전 팁
- 캐싱 전략을 선택할 때는, 데이터의 불변성과 캐싱의 부재를 고려해야 한다.
- getStaticProps와 함께 revalidate를 사용하여 캐싱과 갱신을 적용한다.
- 캐싱된 데이터와 페이지는 서버의 부담을 가중시킬 수 있으므로, 캐싱 크기와 갱신 주기를 적절하게 조정해야 한다.

### 한 줄 정리
Next.js 캐싱 전략은 Request Memoization, Data Cache, Full Route Cache를 포함하는 기술로 웹 페이지 로딩 속도와 사용자 경험을 개선할 수 있다.