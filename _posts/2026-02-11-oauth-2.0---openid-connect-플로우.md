---
title: "[Deep Dive] OAuth 2.0 / OpenID Connect 플로우"
date: 2026-02-11 08:16:46 +0900
categories: [개발뉴스]
tags: [CS, 심화]
---

## 표면적 이해
OAuth 2.0과 OpenID Connect는 안전하고 표준화된 방식으로 사용자 인증과 권한 부여를 처리하는 기술입니다.

## Deep Dive

### 왜 필요한가?
- 이 기술이 해결하는 문제: 사용자 인증과 권한 부여를 안전하고 표준화된 방식으로 처리하는 문제입니다. 이전에는 각기 다른 인증 방식을 제공하거나, 사용자 계정 정보를 직접 관리해야 하는 문제가 있었습니다.
- 이전 방식의 한계: 이전에는 사용자 인증과 권한 부여를 처리하기 위해 다양한 방식을 사용했습니다. 그러나 이러한 방식은 보안 취약점을 가지고 있었으며, 사용자 경험을 저하시킬 수 있었습니다.

### 내부 동작 원리
- 핵심 메커니즘 설명: OAuth 2.0과 OpenID Connect는 클라이언트와 서버가 상호 작용하여 사용자 인증과 권한 부여를 처리하는 메커니즘입니다. 클라이언트는 사용자 인증과 권한 부여를 요청하고, 서버는 사용자 인증과 권한 부여를 처리하여 결과를 클라이언트에게 반환합니다.
- ASCII 다이어그램으로 시각화:
```
+--------+                                   +---------------+
|  클라이언트  |                                   |  인증 서버  |
+--------+                                   +---------------+
     |                                             |
     |  사용자 인증과 권한 부여 요청          |  사용자 인증과 권한 부여 처리
     |                                             |
     |  Redirect_uri                          |  Redirect_uri
     v                                             v
+--------+                                   +---------------+
|  Redirect_uri |                                   |  토큰 발급  |
+--------+                                   +---------------+
     |                                             |
     |  토큰 요청                               |  토큰 반환
     |                                             |
     v                                             v
+--------+                                   +---------------+
|  토큰 검증  |                                   |  사용자 정보  |
+--------+                                   +---------------+
```

### 코드로 이해하기
```typescript
// 인증 서버 설정
const authServer = {
  clientId: 'client-id',
  clientSecret: 'client-secret',
  redirectUri: 'http://localhost:3000/callback',
  scopes: ['openid', 'profile', 'email'],
};

// 사용자 인증과 권한 부여 요청
const authUrl = `https://auth.example.com/authorize?client_id=${authServer.clientId}&redirect_uri=${authServer.redirectUri}&scope=${authServer.scopes.join(' ')}&response_type=code`;

// Redirect_uri 설정
const redirectUri = (req, res) => {
  const code = req.query.code;
  // 토큰 발급
  const tokenUrl = `https://auth.example.com/token?grant_type=authorization_code&code=${code}&redirect_uri=${authServer.redirectUri}&client_id=${authServer.clientId}&client_secret=${authServer.clientSecret}`;
  // 토큰 요청
  fetch(tokenUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  })
    .then((response) => response.json())
    .then((tokenResponse) => {
      // 토큰 검증
      const accessToken = tokenResponse.access_token;
      const idToken = tokenResponse.id_token;
      // 사용자 정보 요청
      const userinfoUrl = `https://auth.example.com/userinfo?access_token=${accessToken}`;
      fetch(userinfoUrl, {
        method: 'GET',
        headers: { Authorization: `Bearer ${accessToken}` },
      })
        .then((response) => response.json())
        .then((userinfoResponse) => {
          // 사용자 정보 처리
          console.log(userinfoResponse);
        });
    });
};
```

### 비교 분석

| 구분 | OAuth 2.0 | OpenID Connect | SAML |
|------|---|---|---|
| 사용목적 | 권한 부여 | 사용자 인증과 권한 부여 | 사용자 인증 |
| 보안수준 | 중 | 중 | 높 |
| 표준화 | O | O | O |

### 실전 팁
- Best Practice: HTTPS를 사용하여 통신을 보안합니다. 클라이언트 비밀키를 안전하게 관리합니다.
- 흔한 실수와 해결법: 토큰을 잘못 사용하여 사용자 정보를 잘못 처리하는 경우가 있습니다. 토큰을 올바르게 사용하여 사용자 정보를 처리하십시오.
- 성능 관련 주의사항: 통신의 병목 현상을 방지하기 위해 적절한 캐싱과 연결 풀링을 사용하십시오.

### 한 줄 정리
OAuth 2.0과 OpenID Connect는 안전하고 표준화된 방식으로 사용자 인증과 권한 부여를 처리하는 기술입니다.